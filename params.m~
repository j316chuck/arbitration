function [params] = load_params()
    %% Read in Map Data
    map_name = './maps/bookstore.png'; 
    map_yaml = './maps/bookstore.yaml';
    map_data = yaml.ReadYaml(map_yaml);
    obs_data_2d = imread(map_name); 
    obs_data_2d = double(obs_data_2d) / 255;
    params.map_data = map_data;
    params.obs_data = obs_data_2d;

    %% Resize the occupancy grid to fit the desired grid size
    % create grid representing the raw image 
    gmin_img = [map_data.origin{1}, map_data.origin{2}];
    gmax_img = gmin_img + map_data.resolution * size(obs_data_2d);
    gnum_img = size(obs_data_2d);
    grid_img = createGrid(gmin_img, gmax_img, gnum_img);
    params.grid_img = grid_img;
   
    % create grid representing the new image size
    gmin_2d = [-10; -10];
    gmax_2d = [5.4; 5.4];
    gnum_2d = [41; 41];
    grid_2d = createGrid(gmin_2d, gmax_2d, gnum_2d);
    params.grid_2d = grid_2d;
    
    % Define 3D grid
    gmin_3d = [gmin_2d; -pi];   % Lower corner of computation domain
    gmax_3d = [gmax_2d; pi];    % Upper corner of computation domain
    gnum_3d = [gnum_2d; 16];    % Number of grid points per dimension
    pdDim = 3;                  % 3rd dimension is periodic
    grid_3d = createGrid(gmin_3d, gmax_3d, gnum_3d, pdDim);
    params.grid_3d = grid_3d; 
    
    % create an array of points at which to interpolate old image
    pts = [grid_2d.xs{1}(:), grid_2d.xs{2}(:)];
    % interpolate old map into newly-sized map
    occ_map = eval_u(grid_img, obs_data_2d, pts);
    occ_map = reshape(occ_map, gnum_2d');
    occ_map(occ_map < map_data.free_thresh) = 0;
    occ_map(occ_map >= map_data.free_thresh) = 1; 
    % +0 for free 1 for occupied
    params.occ_map = occ_map; 
    % +1 for free -1 for occupied 
    binary_occ_map = 1 - 2 * occ_map;
    params.binary_occ_map = binary_occ_map;
    % compute fmm map
    signed_obs_map = compute_fmm_map(grid_2d, binary_occ_map);
    masked_obs_map = signed_obs_map .* occ_map;
    params.obs_map = signed_obs_map;
    params.masked_obs_map = masked_obs_map;
    
    %% Navigation Task
    params.start = [1; 1; 0; 0.01];
    params.goal = [3, 2.75, pi/2, 0.01];
    params.goal_radius = 0.5;
    params.goal_map_2d = shapeCylinder(params.grid_2d, 3, params.goal(1:2), params.goal_radius);
    params.goal_map_3d = shapeCylinder(params.grid_3d, 3, params.goal(1:3), params.goal_radius); 
  
    %% Planners 
    % General dynSys
    params.wMax = 1;
    params.vRange = [0.1, 1.0]; %[0, 0.65]
    params.dMax = [0.1, 0.1];
    params.num_waypts = 50;
    params.horizon = 5;
    params.dt = horizon / (num_waypts - 1);
    
    % reach avoid dynSys
    xstart = params.start(1:3);
    wMax = params.wMax;
    vRange = params.vRange;
    dMax = params.dMax;
    reachAvoidDynSys = Plane(xstart, wMax, vRange, dMax); 
    params.reachAvoidDynSys = reachAvoidDynSys; 
    % reach avoid schemeData
    reachAvoidSchemeData.dynSys = params.reachAvoidDynSys;
    reachAvoidSchemeData.grid = grid_3d;
    reachAvoidSchemeData.uMode = 'min';
    reachAvoidSchemeData.dMode = 'max';
    params.reachAvoidSchemeData = reachAvoidSchemeData;
    % reach avoid planner
    params.reach_avoid_obstacle = -repmat(params.obs_map, 1, 1, params.grid_3d.N(3));
    optTrajDt = params.dt;
    reach_avoid_planner.solve_reach_avoid(params.start(1:3), params.goal(1:3), params.goal_map_3d, params.reach_avoid_obstacle, params.dt);   
    
    
    
    % avoid brs dynSys
    xstart = start(1:3);
    wMax = params.wMax; 
    vRange = params.vRange; 
    dMax = params.dMax; 
    avoidBrsDynSys = Plane(xstart, wMax, vRange, dMax); 
    params.avoidBrsDynSys = avoidBrsDynSys; 
    % avoid brs schemeData   
    avoidBrsSchemeData.dynSys = params.avoidBrsDynSys;
    avoidBrsSchemeData.grid = grid_3d;
    avoidBrsSchemeData.uMode = 'max';
    avoidBrsSchemeData.dMode = 'min';
    params.avoidBrsSchemeData = avoidBrsSchemeData; 
   
    
         
    % Spline Planner
    params.use_mpc = true; 
    params.spline_planner = SplinePlanner(num_waypts, horizon, env.grid_2d, env. 
    
    
end 