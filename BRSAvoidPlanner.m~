classdef BRSAvoidPlanner < handle
    %BRSAvoidPLANNER Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        grid %3d
        schemeData
        dynSys
        tau
        obstacle_map
        data
        data_tau
        valueFun
        extraArgs
    end
    
    methods
        %% Constructs BRS Avoid Planner.
        function obj = BRSAvoidPlanner(grid_3d, schemeData, tau)
            if ~isequal(schemeData.uMode, 'max')
                error("OptCtrl need to maximize distance to obstacle");
            end
           if ~isequal(schemeData.dMode, 'min')
                error("OptDistb needs to minimize distance to obstacle");
            end
            obj.grid = grid_3d;
            obj.schemeData = schemeData; 
            obj.dynSys = schemeData.dynSys;
            obj.tau = tau;
            % Extra Args
            obj.extraArgs.visualize = true;
            obj.extraArgs.plotData.plotDims = [1 1 0];
        end
        
        %% Solves the brs avoid problem
        function solve_brs_avoid(obj, obstacle_map)
            if ~isequal(size(obstacle_map), obj.grid.N')
                error("Shape of obstacle_map is not equal to the grid shape");
            end
            obj.obstacle_map = obstacle_map;
            % Solve 
            [obj.data, obj.data_tau, ~] = ...
                HJIPDE_solve(obj.obstacle_map, obj.tau, obj.schemeData, 'minVOverTime', obj.extraArgs);          
            obj.valueFun = obj.data(:, :, :, end);
            o
        end 
       

        function [uOpt, value] = compute_avoid_u(obj, x)
            value = eval_u(obj.grid, obj.valueFun, x);
            % Value of the derivative at that particular state
            current_deriv = eval_u(grid, deriv, x);
            % Get the optimal control to apply at this state
            uOpt = dynSys.optCtrl(x, current_deriv, uMode);
        end
    end
end

